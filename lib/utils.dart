import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:source_gen/source_gen.dart';
import 'annotation.dart';

bool isColumnField(FieldElement field) {
  // print("isColumnField : checking column field ${field.name}");
  if (field.metadata.length == 0) {
    return false;
  }
  var annotation = getAnnotation(field, ColumnInfo);
  // print("isColumnField : ${annotation != null}");
  return annotation != null;
}

bool isPrimaryKeyField(FieldElement field) {
  // print("isColumnField : checking column field ${field.name}");
  if (field.metadata.length == 0) {
    return false;
  }
  var annotation = getAnnotation(field, PrimaryKey);
  // print("isColumnField : ${annotation != null}");
  return annotation != null;
}

bool isAutoGeneratedPrimaryKeyField(FieldElement field) {
  // print("isColumnField : checking column field ${field.name}");
  if (field.metadata.length == 0) {
    return false;
  }
  var annotation = getAnnotation(field, PrimaryKey);
  if (annotation == null) return false;

  var autoGenerated = annotation.peek('autoGenerated')?.boolValue;
  // print("isColumnField : ${annotation != null}");
  return autoGenerated != null && autoGenerated == true;
}

String getFieldSqlType(FieldElement field) {
  switch (field.type.element!.name) {
    case "int":
    case "DateTime":
      return "integer";
    case "double":
      return "numeric";
    case "Uint8List":
      return "blob";
    default:
      return "text";
  }
}

bool isEntityClass(ClassElement element) {
  var annotation = getAnnotation(element, Entity);

  return annotation != null;
}

bool isCollectionField(FieldElement field) {
  ClassElement collectionClass = field.type.element as ClassElement;
  if (collectionClass.metadata.length == 0) {
    return false;
  }
  var annotation = getAnnotation(collectionClass, Collection);
  return annotation != null;
}
// bool isCollectionMethod(MethodElement method) {
//   ClassElement collectionClass = method.type.element;
// }

bool isQueryMethod(MethodElement method) {
  if (method.metadata.length == 0) {
    return false;
  }
  var annotation = getAnnotation(method, Query);
  return annotation != null;
}

bool isUpdateMethod(MethodElement method) {
  if (method.metadata.length == 0) {
    return false;
  }
  var annotation = getAnnotation(method, Update);
  return annotation != null;
}

bool isUpdateMethodHasConditions(MethodElement method) {
  if (!isUpdateMethod(method)) return false;

  var annotation = getAnnotation(method, Update);
  var condition = annotation?.peek('conditions')?.listValue;

  return condition != null;
}

bool isUpdateMethodReturnOperation(MethodElement method) {
  if (!isUpdateMethod(method)) return false;

  var returnType = method.returnType.getDisplayString(withNullability: false);
  return returnType == "UpdateOperation" || returnType.contains("Operation");
}

bool isInsertMethod(MethodElement method) {
  var requiredParameters =
      method.parameters.where((element) => element.isRequiredPositional);
  var annotation = getAnnotation(method, Insert);

  if (annotation != null && requiredParameters.length == 0) {
    throw InvalidGenerationSourceError(
      'Generator cannot create the target method `${method.name}` because it doesn\'t have required parameter.',
      todo:
          'Remove the [Insert] annotation from method `${method.name}` or define your parameter.',
    );
  } else if (annotation != null && requiredParameters.length > 1) {
    throw InvalidGenerationSourceError(
      'Generator cannot create the target method `${method.name}` because it have multiple required parameters.',
      todo:
          'Remove the [Insert] annotation from the method `${method.name}` or remove other parameters.',
    );
  }
  return annotation != null;
}

TypeChecker typeChecker(Type type) => TypeChecker.fromRuntime(type);

ConstantReader? getFieldAnnotation(FieldElement field, Type type) {
  final annot =
      typeChecker(type).firstAnnotationOf(field, throwOnUnresolved: false);
  if (annot != null) return ConstantReader(annot);

  return null;
}

ConstantReader? getMethodAnnotation(MethodElement method, Type type) {
  final annot =
      typeChecker(type).firstAnnotationOf(method, throwOnUnresolved: false);
  if (annot != null) return ConstantReader(annot);
  return null;
}

ConstantReader? getClassAnnotation(ClassElement clazz, Type type) {
  final annot =
      typeChecker(type).firstAnnotationOf(clazz, throwOnUnresolved: false);
  if (annot != null) return ConstantReader(annot);
  return null;
}

ConstantReader? getAnnotation(Element element, Type type) {
  final metadata = element.metadata;

  for (var meta in metadata) {
    var annotation = ConstantReader(meta.computeConstantValue());
    if (annotation.instanceOf(typeChecker(type))) {
      return annotation;
    }
  }
  return null;
}

bool isUpdateQuery(dynamic query) {
  if (query is String) {
    return query.toLowerCase().startsWith("update");
  } else if (query is MethodElement) {
    if (query.metadata.length == 0) {
      return false;
    }
    var annotation = getAnnotation(query, Update);
    return annotation != null;
  }
  return false;
}

String getClassMethodBody(ClassElement clazz, MethodElement method) {
  var session = method.session!;
  ParsedLibraryResult parsedLibResult =
      session.getParsedLibraryByElement(clazz.library) as ParsedLibraryResult;
  ElementDeclarationResult declaration =
      parsedLibResult.getElementDeclaration(method)!;

  var source = declaration.node
      .toSource()
      .replaceAll("@override ", "")
      .replaceAll(
          RegExp(r"^[a-zA-Z]+\s[a-zA-Z]+\((.*?)\)\s?{", multiLine: true), "");

  var lastIndex = source.lastIndexOf("}");
  source = source.replaceRange(lastIndex, lastIndex + 1, "");
  // print("method source $source");
  return source;
}

String getClassFieldValue(ClassElement clazz, FieldElement field) {
  var session = field.session!;
  ParsedLibraryResult parsedLibResult =
      session.getParsedLibraryByElement(clazz.library) as ParsedLibraryResult;
  ElementDeclarationResult declaration =
      parsedLibResult.getElementDeclaration(field)!;

  return declaration.node.toSource().split("=").last;
}

bool classFieldHasAssignment(ClassElement clazz, FieldElement field) {
  var session = field.session!;
  ParsedLibraryResult parsedLibResult =
      session.getParsedLibraryByElement(clazz.library) as ParsedLibraryResult;
  ElementDeclarationResult declaration =
      parsedLibResult.getElementDeclaration(field)!;
  //print("classFieldHasAssignment ${declaration.node.toSource().split("=")}");
  return declaration.node.toSource().split("=").length > 1;
}

bool classParameterHasAssignment(
    ClassElement clazz, ParameterElement parameter) {
  var session = parameter.session!;
  ParsedLibraryResult parsedLibResult =
      session.getParsedLibraryByElement(clazz.library) as ParsedLibraryResult;
  ElementDeclarationResult declaration =
      parsedLibResult.getElementDeclaration(parameter)!;
  // print(
  //     "classParameterHasAssignment ${declaration.node.toSource().split("=")}");

  return declaration.node.toSource().split("=").length > 1;
}

String getParameterAssignment(ClassElement clazz, ParameterElement parameter) {
  var session = parameter.session!;
  ParsedLibraryResult parsedLibResult =
      session.getParsedLibraryByElement(clazz.library) as ParsedLibraryResult;
  ElementDeclarationResult declaration =
      parsedLibResult.getElementDeclaration(parameter)!;

  return declaration.node.toSource().split("=").last;
}

bool isIntegerType(String type) {
  return type == "int" || type == "int?";
}

bool isFloatType(String type) {
  return type == "Float" || type == "Float?";
}

bool isDoubleType(String type) {
  return type == "Double" || type == "Double?";
}

bool isStringType(String type) {
  return type == "String" || type == "String?";
}

bool isNullableType(String type) {
  return type.endsWith("?");
}
